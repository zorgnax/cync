#!/usr/bin/perl
# synchronize directories based on find(1)

# its meant to be simple, not particularly efficient. if you rename a
# directory, this will delete the old one and transfer the new one. if you
# make a small change to a large file, the whole file will be
# transferred. it works one way. if you need to do two way synchronization,
# use git or rsync. this will never touch the source directory, only
# the destination will be changed.

use Getopt::Long;
use Data::Dumper;
use strict;
use warnings;

my ($noact, $src, $dest, @find_args);
parse_options() or usage();
sync_all();

sub usage {
    print "Usage: $0 [-n] <src> <dest> [find-args]\n";
    exit;
}

sub parse_options {
    GetOptions(
        noact => \$noact,
        '<>' => sub {$src = parse_ref($_[0]); die "!FINISH"})
        or return;
    $dest = parse_ref(shift @ARGV);
    return if !$src || !$dest;
    @find_args = @ARGV;
    return 1;
}

sub parse_ref {
    my ($ref) = @_;
    return if !$ref;
    $ref =~ s{/*$}{}g;
    if ($ref =~ /([^:]+):(.*)/) {
        return {host => $1, file => $2, ref => $ref};
    }
    return {host => "", file => $ref, ref => $ref};
}

sub sync_all {
    my $src_files = find($src);
    my $dest_files = find($dest);
    my %processed;
    for my $name (sort keys %$src_files, keys %$dest_files) {
        next if $processed{$name}++;
        sync($name, $src_files->{$name}, $dest_files->{$name});
    }
    print STDERR "done!\n";
}

sub find {
    my ($ref) = @_;
    my %files;
    my @cmd = ("find", $ref->{file}, @find_args);
    unshift @cmd, "ssh", $ref->{host} if $ref->{host};
    print STDERR "@cmd\n";
    push @cmd, "-printf", "%y %Ts %m \\0%p\\0 \\0%l\\0\\n";
    open my $fh, "-|", @cmd;
    while (<$fh>) {
        my ($type, $mtime, $mode, $name, $target) =
            /(.) (\d+) (\d+) \0(.+)\0 \0(.*)\0/ or next;
        $name =~ s{^\Q$ref->{file}\E?}{};
        $files{$name} = {
            type => $type, mtime => $mtime, mode => $mode, target => $target,
        };
    }
    close $fh;
    return \%files;
}

sub sync {
    my ($name, $a, $b) = @_;
    rm($name, $a, $b);
    cp($name, $a, $b);
    ln($name, $a, $b);
    makedir($name, $a, $b);
    chmode($name, $a, $b);
    touch($name, $a, $b);
}

sub mysystem {
    my ($ref, @cmd) = @_;
    unshift @cmd, "ssh", $ref->{host} if $ref && $ref->{host};
    print STDERR "@cmd\n";
    return if $noact;
    system @cmd;
    exit($?>>8) if $?>>8;
}

sub rm {
    my ($name, $a, $b) = @_;
    return if !$b || $a && $a->{type} eq $b->{type};
    mysystem $dest, "rm", "-r", "$dest->{file}$name";
}

sub cp {
    my ($name, $a, $b) = @_;
    return if !$a;
    return if $a->{type} ne "f";
    return if $b && $b->{mtime} eq $a->{mtime};
    $a->{synced} = 1;
    my $cp = $src->{host} || $dest->{host} ? "scp" : "cp";
    mysystem undef, $cp, "$src->{ref}$name", "$dest->{ref}$name";
}

sub ln {
    my ($name, $a, $b) = @_;
    return if !$a;
    return if $a->{type} ne "l";
    return if $b && $b->{target} eq $a->{target};
    $a->{synced} = 1;
    mysystem $dest, "ln", "-s", $a->{target}, "$dest->{file}$name";
}

sub makedir {
    my ($name, $a, $b) = @_;
    return if !$a;
    return if $a->{type} ne "d";
    return if $b;
    $a->{synced} = 1;
    mysystem $dest, "mkdir", "$dest->{file}$name";
}

sub chmode {
    my ($name, $a, $b) = @_;
    return if !$a;
    return if $a->{type} eq "l";
    return if !$a->{synced} && $b && $b->{mode} eq $a->{mode};
    $a->{synced} = 1;
    mysystem $dest, "chmod", $a->{mode}, "$dest->{file}$name";
}

sub touch {
    my ($name, $a, $b) = @_;
    return if !$a;
    return if !$a->{synced};
    return if $a->{type} eq "l";
    mysystem $dest, "touch", "-d", "\@$a->{mtime}", "$dest->{file}$name";
}

